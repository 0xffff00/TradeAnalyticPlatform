在C#中使用mathnet，需要利用using引入相关类

矩阵运算的相关类：

using MathNet.Numerics.LinearAlgebra.Double;

using MathNet.Numerics.LinearAlgebra.Generic;

矩阵定义和初始化
       常用矩阵初始化函数：

        var matrix2 = new DenseMatrix(3);  //3维方阵

        var matrix3 = new DenseMatrix(2, 3); //2×3矩阵

         var matrix4 = new DenseMatrix(2, 3, 3.0); //2×3矩阵，所有值为3.0

         var matrixI = DenseMatrix.Identity(5); //5维单位矩阵

       矩阵操作和C#中的数组操作一致，matrix2[m,n]取其m行n列上的值或对其赋值

 

         MathNet中重载了.ToString()函数，可以直接用matrix.ToString()输出整个数组，大大方便了调试和保存数据。

      也可以利用C#中的double[,]直接创建

         double[,] d_matrix = new double[2,3];

 var matrix2 = new DenseMatrix(d_matrix); //2×3矩阵

        小记：我曾做过测试，将double[,]先转成Math矩阵，然后进行矩阵运算，再利用matrix2.ToArray()将Math矩阵转换成double[,]，其运算时间和直接利用C#编写的矩阵运算相差很小。

 但如果是利用for循环将double数组的数值赋值给Math矩阵进行矩阵运算，然后再利用for循环将Math矩阵赋值给某个double[，]数组，其运算时间可以减少1/3。在开发效率和运算效率上，使用的时候可以根据需要进行取舍。

 

2.矩阵操作

     矩阵操作最常用的莫过于从一个矩阵中取值

            var submatrix = matrix.SubMatrix(2, 2, 3, 3); //取从第二行开始的2行，第三列开始的三列 子矩阵

            var row = matrix.Row(5, 3, 4); //取从第5行第3列开始的4个行元素

            var column = matrix.Column(2, 6, 3); //取从第2列第6行开始的3个列元素

             matrix.ColumnEnumerator(2, 4) //取从第2列开始的4列

             matrix.RowEnumerator(4, 3)//取从第4行开始的3行

            matrix.ToRowWiseArray()/matrix.ToColumnWiseArray() //矩阵变为行向量或者列向量

           matrix.Diagonal()//取矩阵的对角线元素向量

     向矩阵中插值

          var result = matrix.InsertColumn(3, vector)/matrix.InsertRow(3, vector);//将向量vector插入到指定的行/列，原有的行列顺延

           matrix.SetColumn(2, (Vector)vector);/matrix.SetRow(3, (double[])vector);  //用vector替换指定的行/列

     matrix.SetSubMatrix(1, 3, 1, 3, DenseMatrix.Identity(3)); //用矩阵替换指定位置的块矩阵

          matrix.SetDiagonal(new[] { 5.0, 4.0, 3.0, 2.0, 1.0 });  //替换矩阵的对角线元素

          matrixA.Append(matrixB,result)/matrixA.Stack(matrixB,result) //将matrixB扩展到matrixA的右方/上方，将结果保存在result中

    矩阵转换：   

           var permutations = new Permutation(new[] { 0, 1, 3, 2, 4 });

    matrix.PermuteRows(permutations);   //互换矩阵的3，4行

 

            permutations = new Permutation(new[] { 1, 0, 4, 3, 2 });

            matrix.PermuteColumns(permutations);  //互换矩阵的1，2列，3，5列。

            可以看出，互换是由Permutation中的数字序号决定的。




1.矩阵运算

            matrixA = 3.0 * matrixB    //数乘

            matrixA = vector * matrixB  /matrixA =  matrixB * vector  //向量乘

            matrixC = matrixA + / - / * matrixB   //矩阵加、减、乘

            resultM = (DenseMatrix)matrixA.PointwiseDivide(matrixB); //点乘

           上述所有运算符都有对应的函数，也可是利用函数进行运算，如“+”可以写成   matrixC = (DenseMatrix)matrixA.Add(matrixB);或者matrixA.Add(matrixB, matrixC);

            matrixB = matrixA.Inverse()/Transpose()  //求逆和转置

2.求解线性方程组

            对于一阶线性方程组

     5*x + 2*y - 4*z = -7

             3*x - 7*y + 6*z = 38

             4*x + 1*y + 5*z = 43

             可以如下求解：

              var matrixA = new DenseMatrix(new[,] { { 5.00, 2.00, -4.00 }, { 3.00, -7.00, 6.00 }, { 4.00, 1.00, 5.00 } });

              var vectorB = new DenseVector(new[] { -7.0, 38.0, 43.0 });

 

               var resultX = matrixA.LU().Solve(vectorB);

或者

              resultX = matrixA.QR().Solve(vectorB);

或者

              matrixA.Svd(true).Solve(vectorB, resultX);

或者

              matrixA.GramSchmidt().Solve(vectorB, resultX);

3.矩阵秩、行列式、trace和范数

         matrix.Determinant()/Rank()/ConditionNumber()/Trace()   //行列式/秩/条件数/trace

        matrix.L1Norm()/L2Norm()/FrobeniusNorm()/InfinityNorm()   //范数
